<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart City: Sewer & AI Segregation</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #0f172a; }
        #ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(15, 23, 42, 0.95);
            color: #f1f5f9;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            width: 240px;
            z-index: 100;
            border: 1px solid rgba(56, 189, 248, 0.4);
        }
        h2 { margin: 0 0 8px 0; color: #38bdf8; font-size: 1rem; border-bottom: 1px solid #334155; padding-bottom: 6px; }
        p { font-size: 0.7rem; color: #94a3b8; line-height: 1.4; margin-bottom: 12px; }
        .controls { display: flex; flex-direction: column; gap: 6px; }
        button {
            padding: 8px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            font-size: 0.65rem;
            letter-spacing: 0.5px;
        }
        #day-night-btn { background: #334155; color: white; }
        #trash-btn { background: #0ea5e9; color: white; }
        #xray-btn { background: #6366f1; color: white; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }
        button.active { outline: 2px solid #fff; box-shadow: 0 0 10px #6366f1; }
        
        .label-3d {
            background: rgba(15, 23, 42, 0.9);
            color: #38bdf8;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: bold;
            border: 1px solid #38bdf8;
            pointer-events: none;
            white-space: nowrap;
        }
        .ai-status {
            margin-top: 10px;
            padding: 6px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            font-family: monospace;
            font-size: 9px;
            color: #22c55e;
            border-left: 2px solid #22c55e;
        }
    </style>
</head>
<body>

    <div id="ui-overlay">
        <h2>Sewer Management</h2>
        <p>Toggle <b>Underground View</b> to see only the pipe network and segregation hub. Click a pipe to simulate a leak.</p>
        <div class="controls">
            <button id="xray-btn">üî≠ Underground View</button>
            <button id="day-night-btn">üåô Night Mode</button>
            <button id="trash-btn">üóëÔ∏è Drop Waste</button>
        </div>
        <div class="ai-status" id="status-log">SYSTEM STATUS: READY</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        let scene, camera, renderer, labelRenderer, controls;
        let isNight = false, isXray = false;
        let trashItems = [], steamParticles = [], waterParticles = [], pipes = [];
        let scannerLaser, nightBot, inspectionBot;
        let currentLeak = null, surfaceGroup, industryGroup, segregationGroup;

        const CATEGORIES = [
            { name: 'Organic', color: 0x22c55e, offsetZ: 20 },
            { name: 'Plastic', color: 0xeab308, offsetZ: 0 },
            { name: 'Metal', color: 0x64748b, offsetZ: -20 }
        ];

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xb3e5fc);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(160, 100, 160);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            labelRenderer = new CSS2DRenderer();
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.domElement.style.position = 'absolute';
            labelRenderer.domElement.style.top = '0px';
            labelRenderer.domElement.style.pointerEvents = 'none';
            document.body.appendChild(labelRenderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
            sunLight.position.set(100, 100, 50);
            sunLight.castShadow = true;
            scene.add(sunLight);

            // Ground Base (Keep separate so it can hide)
            surfaceGroup = new THREE.Group();
            const baseGeo = new THREE.BoxGeometry(300, 45, 180);
            const baseMat = new THREE.MeshStandardMaterial({ color: 0xf3f4f6 });
            const base = new THREE.Mesh(baseGeo, baseMat);
            base.position.y = -22.6;
            surfaceGroup.add(base);

            const grass = new THREE.Mesh(new THREE.PlaneGeometry(300, 180), new THREE.MeshStandardMaterial({ color: 0x10b981 }));
            grass.rotation.x = -Math.PI / 2;
            surfaceGroup.add(grass);

            const road = new THREE.Mesh(new THREE.PlaneGeometry(300, 40), new THREE.MeshStandardMaterial({ color: 0x1e293b }));
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.05;
            surfaceGroup.add(road);
            scene.add(surfaceGroup);

            // Industry
            industryGroup = new THREE.Group();
            createIndustry(-100, 0);
            createAirFiltration(-60, 0);
            createWaterFiltration(-60, -50);
            scene.add(industryGroup);

            // Undergound Components
            createUndergroundSystem();
            segregationGroup = new THREE.Group();
            createSegregationBoxes(120, -20, 0);
            scene.add(segregationGroup);

            // Inlets
            createHalfPipeCurb(-20, 20, 0); 
            createHalfPipeCurb(-20, -20, Math.PI); 
            createHalfPipeCurb(40, 20, 0); 
            createHalfPipeCurb(40, -20, Math.PI); 

            // UI Events
            document.getElementById('day-night-btn').addEventListener('click', toggleNight);
            document.getElementById('trash-btn').addEventListener('click', dropTrash);
            document.getElementById('xray-btn').addEventListener('click', toggleXray);
            window.addEventListener('mousedown', onMouseDown);
        }

        function createIndustry(x, z) {
            const industry = new THREE.Group();
            industry.position.set(x, 0, z);
            const factory = new THREE.Mesh(new THREE.BoxGeometry(40, 30, 30), new THREE.MeshStandardMaterial({ color: 0x334155, metalness: 0.8 }));
            factory.position.y = 15;
            industry.add(factory);

            for(let i=0; i<2; i++) {
                const stack = new THREE.Mesh(new THREE.CylinderGeometry(3, 4, 40), new THREE.MeshStandardMaterial({ color: 0x1e293b }));
                stack.position.set(-10 + i*20, 35, -5);
                industry.add(stack);
                for(let j=0; j<8; j++) {
                    const p = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshBasicMaterial({ color: 0x444444, transparent: true, opacity: 0.6 }));
                    p.position.copy(stack.position).y += 22 + j*5;
                    p.position.x += 10;
                    industry.add(p);
                    steamParticles.push({ mesh: p, startX: p.position.x, startY: p.position.y });
                }
            }
            industryGroup.add(industry);
        }

        function createAirFiltration(x, z) {
            const scrubber = new THREE.Mesh(new THREE.CylinderGeometry(10, 10, 35), new THREE.MeshStandardMaterial({ color: 0x64748b, metalness: 0.9 }));
            scrubber.position.set(x, 17.5, z);
            industryGroup.add(scrubber);
        }

        function createWaterFiltration(x, z) {
            const tank = new THREE.Mesh(new THREE.CylinderGeometry(12, 12, 15), new THREE.MeshPhysicalMaterial({ color: 0x94a3b8, transparent: true, opacity: 0.4 }));
            tank.position.set(x, 7.5, z);
            industryGroup.add(tank);
        }

        function createHalfPipeCurb(x, z, rotation) {
            const sewer = new THREE.Group();
            sewer.position.set(x, 0.5, z);
            const halfPipeGeo = new THREE.CylinderGeometry(4, 4, 15, 32, 1, true, 0, Math.PI);
            const halfPipeMat = new THREE.MeshStandardMaterial({ color: 0x334155, side: THREE.DoubleSide });
            const halfPipe = new THREE.Mesh(halfPipeGeo, halfPipeMat);
            halfPipe.rotation.z = Math.PI / 2;
            halfPipe.rotation.x = Math.PI / 2 + rotation;
            sewer.add(halfPipe);
            const chute = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 22), new THREE.MeshStandardMaterial({ color: 0x334155 }));
            chute.position.y = -11;
            sewer.add(chute);
            surfaceGroup.add(sewer);
        }

        function createUndergroundSystem() {
            const config = [
                { z: 0, r: 6, color: 0x38bdf8, name: "Main Waste Pipe" },
                { z: 15, r: 4, color: 0x4b5563, name: "Sewage Pipe A" },
                { z: -15, r: 4, color: 0x4b5563, name: "Sewage Pipe B" }
            ];

            config.forEach(c => {
                const geo = new THREE.CylinderGeometry(c.r, c.r, 260);
                geo.rotateZ(Math.PI / 2);
                const mat = new THREE.MeshPhysicalMaterial({ color: c.color, transparent: true, opacity: 0.5, transmission: 0.5 });
                const p = new THREE.Mesh(geo, mat);
                p.position.set(0, -20, c.z);
                p.userData = { isPipe: true, zPos: c.z, label: c.name };
                scene.add(p);
                pipes.push(p);
                addLabel(c.name, 0, -28, c.z);
            });

            inspectionBot = new THREE.Group();
            const iBody = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 5), new THREE.MeshStandardMaterial({ color: 0x0ea5e9 }));
            iBody.rotation.z = Math.PI / 2;
            inspectionBot.add(iBody);
            const lens = new THREE.Mesh(new THREE.SphereGeometry(1), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
            lens.position.x = 3;
            inspectionBot.add(lens);
            const iLight = new THREE.PointLight(0x00ffff, 20, 15);
            iLight.position.set(3, 0, 0);
            inspectionBot.add(iLight);
            inspectionBot.position.set(0, -20, 0);
            inspectionBot.userData = { mode: 'idle' };
            scene.add(inspectionBot);

            nightBot = new THREE.Group();
            const botBody = new THREE.Mesh(new THREE.BoxGeometry(10, 8, 8), new THREE.MeshStandardMaterial({ color: 0xef4444 }));
            nightBot.add(botBody);
            const plow = new THREE.Mesh(new THREE.BoxGeometry(2, 10, 10), new THREE.MeshStandardMaterial({ color: 0x94a3b8 }));
            plow.position.x = 6;
            nightBot.add(plow);
            nightBot.position.set(-100, -20, 0);
            nightBot.visible = false;
            scene.add(nightBot);

            const hub = new THREE.Group();
            hub.position.set(110, -20, 0);
            const arch = new THREE.Mesh(new THREE.TorusGeometry(12, 1.5, 16, 32, Math.PI), new THREE.MeshStandardMaterial({ color: 0x1e293b }));
            arch.rotation.y = Math.PI/2;
            hub.add(arch);
            const laserMat = new THREE.MeshBasicMaterial({ color: 0xef4444, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            scannerLaser = new THREE.Mesh(new THREE.PlaneGeometry(20, 0.5), laserMat);
            scannerLaser.rotation.x = Math.PI/2;
            hub.add(scannerLaser);
            scene.add(hub);
        }

        function createSegregationBoxes(x, y, z) {
            CATEGORIES.forEach((cat) => {
                const boxGroup = new THREE.Group();
                boxGroup.position.set(x, y, cat.offsetZ);
                const box = new THREE.Mesh(new THREE.BoxGeometry(15, 12, 15), new THREE.MeshStandardMaterial({ color: cat.color, transparent: true, opacity: 0.7 }));
                boxGroup.add(box);
                segregationGroup.add(boxGroup);
                addLabel(cat.name, x, y + 10, cat.offsetZ);
            });
        }

        function addLabel(text, x, y, z) {
            const div = document.createElement('div');
            div.className = 'label-3d';
            div.textContent = text;
            const label = new CSS2DObject(div);
            label.position.set(x, y, z);
            scene.add(label);
        }

        function toggleNight() {
            isNight = !isNight;
            scene.background.set(isNight ? 0x020617 : 0xb3e5fc);
            document.getElementById('day-night-btn').textContent = isNight ? "‚òÄÔ∏è Day Mode" : "üåô Night Mode";
            nightBot.visible = isNight;
            if(!isNight) nightBot.position.x = -100;
        }

        function toggleXray() {
            isXray = !isXray;
            const btn = document.getElementById('xray-btn');
            btn.textContent = isXray ? "üèòÔ∏è Surface View" : "üî≠ Underground View";
            if(isXray) btn.classList.add('active'); else btn.classList.remove('active');

            surfaceGroup.visible = !isXray;
            industryGroup.visible = !isXray;
            
            if(isXray) {
                camera.position.set(0, 0, 180);
                controls.target.set(0, -20, 0);
            } else {
                camera.position.set(160, 100, 160);
                controls.target.set(0, 0, 0);
            }
        }

        function onMouseDown(event) {
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(pipes);
            if (intersects.length > 0) {
                const hit = intersects[0];
                triggerLeak(hit.point, hit.object);
            }
        }

        function triggerLeak(point, pipe) {
            if (currentLeak) scene.remove(currentLeak);
            
            // Visual Leak: A jagged red ring
            const leakGeo = new THREE.TorusGeometry(3, 0.4, 6, 20);
            const leakMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            currentLeak = new THREE.Mesh(leakGeo, leakMat);
            currentLeak.position.copy(point);
            currentLeak.rotation.y = Math.PI/2;
            scene.add(currentLeak);

            // Command bot
            inspectionBot.userData.mode = 'repair';
            inspectionBot.userData.target = point.clone();
            const log = document.getElementById('status-log');
            log.textContent = `CRITICAL: LEAK IN ${pipe.userData.label.toUpperCase()}`;
            log.style.color = "#ef4444";
            log.style.borderLeftColor = "#ef4444";
        }

        function dropTrash() {
            const zPos = Math.random() > 0.5 ? 20 : -20;
            const xPos = Math.random() > 0.5 ? -20 : 40;
            const cat = CATEGORIES[Math.floor(Math.random()*3)];
            const trash = new THREE.Mesh(new THREE.IcosahedronGeometry(1.5), new THREE.MeshStandardMaterial({ color: 0x64748b }));
            trash.position.set(xPos + (Math.random()-0.5)*10, 1, zPos);
            trash.userData = { state: 'on-road', type: cat, scanned: false };
            scene.add(trash);
            trashItems.push(trash);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now();

            steamParticles.forEach(p => { p.mesh.position.x += 0.2; if(p.mesh.position.x > 150) p.mesh.position.x = -10; });
            waterParticles.forEach(p => { p.mesh.position.z -= 0.15; if (p.mesh.position.z < -80) p.mesh.position.z = p.startZ; });

            if (!isNight && inspectionBot) {
                if(inspectionBot.userData.mode === 'repair') {
                    const target = inspectionBot.userData.target;
                    inspectionBot.position.x += (target.x - inspectionBot.position.x) * 0.08;
                    inspectionBot.position.z += (target.z - inspectionBot.position.z) * 0.08;
                    
                    if(inspectionBot.position.distanceTo(target) < 1.5) {
                        inspectionBot.userData.mode = 'fixing';
                        document.getElementById('status-log').textContent = "REPAIR IN PROGRESS...";
                        setTimeout(() => {
                            if(currentLeak) scene.remove(currentLeak);
                            currentLeak = null;
                            inspectionBot.userData.mode = 'idle';
                            const log = document.getElementById('status-log');
                            log.textContent = "SYSTEM NOMINAL. RESUMING PATROL.";
                            log.style.color = "#22c55e";
                            log.style.borderLeftColor = "#22c55e";
                        }, 1500);
                    }
                } else if(inspectionBot.userData.mode === 'idle') {
                    const pipeIndex = Math.floor((time * 0.0002) % 3);
                    const targetZ = [0, 15, -15][pipeIndex];
                    inspectionBot.position.z += (targetZ - inspectionBot.position.z) * 0.05;
                    inspectionBot.position.x = Math.sin(time * 0.001) * 90;
                    inspectionBot.rotation.y = (Math.cos(time * 0.001) > 0) ? 0 : Math.PI;
                }
            }

            if (isNight && nightBot.visible) {
                nightBot.position.x += 0.5;
                if (nightBot.position.x > 150) nightBot.position.x = -120;
            }

            if(scannerLaser) scannerLaser.position.z = Math.sin(time * 0.008) * 10;

            trashItems.forEach((t, i) => {
                if(isNight && t.userData.state === 'on-road') {
                    t.position.y -= 0.5;
                    t.position.z += (0 - t.position.z) * 0.1;
                    if(t.position.y <= -20) t.userData.state = 'in-pipe';
                }
                if(t.userData.state === 'in-pipe') {
                    if (nightBot.position.x > t.position.x - 10 && nightBot.position.x < t.position.x) t.position.x = nightBot.position.x + 8;
                    if(!t.userData.scanned && t.position.x > 105) {
                        t.userData.scanned = true;
                        t.material.color.set(t.userData.type.color);
                    }
                    if(t.userData.scanned && t.position.x > 115) {
                        t.position.z += (t.userData.type.offsetZ - t.position.z) * 0.1;
                        t.position.x += (120 - t.position.x) * 0.1;
                        if(t.position.x > 119) { scene.remove(t); trashItems.splice(i, 1); }
                    }
                }
            });

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
